(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('ngx-lottie', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators', '@angular/platform-browser'], factory) :
    (global = global || self, factory(global['ngx-lottie'] = {}, global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators, global.ng.platformBrowser));
}(this, (function (exports, i0, common, rxjs, operators, i1) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: src/symbols.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function BMEnterFrameEvent() { }
    if (false) {
        /** @type {?} */
        BMEnterFrameEvent.prototype.currentTime;
        /** @type {?} */
        BMEnterFrameEvent.prototype.duration;
        /** @type {?} */
        BMEnterFrameEvent.prototype.totalTime;
        /** @type {?} */
        BMEnterFrameEvent.prototype.type;
    }
    /**
     * @record
     */
    function BMCompleteLoopEvent() { }
    if (false) {
        /** @type {?} */
        BMCompleteLoopEvent.prototype.type;
        /** @type {?} */
        BMCompleteLoopEvent.prototype.loop;
        /** @type {?} */
        BMCompleteLoopEvent.prototype.playCount;
        /** @type {?} */
        BMCompleteLoopEvent.prototype.frameMult;
    }
    /**
     * @record
     */
    function BMCompleteEvent() { }
    if (false) {
        /** @type {?} */
        BMCompleteEvent.prototype.type;
        /** @type {?} */
        BMCompleteEvent.prototype.duration;
    }
    /**
     * @record
     */
    function BMSegmentStartEvent() { }
    if (false) {
        /** @type {?} */
        BMSegmentStartEvent.prototype.type;
        /** @type {?} */
        BMSegmentStartEvent.prototype.firstFrame;
        /** @type {?} */
        BMSegmentStartEvent.prototype.totalFrames;
    }
    /**
     * @record
     */
    function BMDestroyEvent() { }
    if (false) {
        /** @type {?} */
        BMDestroyEvent.prototype.target;
        /** @type {?} */
        BMDestroyEvent.prototype.type;
    }
    /**
     * @record
     */
    function BMRenderFrameErrorEvent() { }
    if (false) {
        /** @type {?} */
        BMRenderFrameErrorEvent.prototype.type;
        /** @type {?} */
        BMRenderFrameErrorEvent.prototype.nativeError;
        /** @type {?} */
        BMRenderFrameErrorEvent.prototype.currentTime;
    }
    /**
     * @record
     */
    function BMConfigErrorEvent() { }
    if (false) {
        /** @type {?} */
        BMConfigErrorEvent.prototype.type;
        /** @type {?} */
        BMConfigErrorEvent.prototype.nativeError;
    }
    /**
     * @record
     */
    function LottieOptions() { }
    if (false) {
        /** @type {?} */
        LottieOptions.prototype.player;
        /** @type {?|undefined} */
        LottieOptions.prototype.useCache;
    }
    /** @type {?} */
    var LOTTIE_OPTIONS = new i0.InjectionToken('LottieOptions');
    /** @type {?} */
    var ANIMATION_CACHE = new i0.InjectionToken('AnimationCache');

    /**
     * @fileoverview added by tsickle
     * Generated from: src/utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} animation
     * @return {?}
     */
    function transformAnimationFilenameToKey(animation) {
        return "animation-" + animation.split('.json')[0];
    }
    /**
     * @param {?} options
     * @param {?} container
     * @param {?} animationCache
     * @return {?}
     */
    function mergeOptionsWithDefault(options, container, animationCache) {
        /** @type {?} */
        var merged = Object.assign({
            container: container,
            renderer: 'svg',
            loop: true,
            autoplay: true,
        }, options);
        return animationCache !== null ? animationCache.transformOptions(merged) : merged;
    }
    /**
     * @param {?} animationCache
     * @param {?} options
     * @param {?} animationItem
     * @return {?}
     */
    function awaitConfigAndCache(animationCache, options, animationItem) {
        if (animationCache === null) {
            return;
        }
        animationItem.addEventListener('config_ready', ( /**
         * @return {?}
         */function () {
            animationCache.set(options, animationItem);
        }));
    }
    /**
     * @param {?} player
     * @return {?}
     */
    function streamifyPlayerOrLoader(player) {
        /** @type {?} */
        var playerOrLoader = player();
        if (playerOrLoader instanceof Promise) {
            return rxjs.from(playerOrLoader).pipe(operators.map(( /**
             * @param {?} module
             * @return {?}
             */function (/**
             * @param {?} module
             * @return {?}
             */ module) { return module.default || module; })), operators.publishReplay(1), operators.refCount());
        }
        else {
            return rxjs.of(playerOrLoader);
        }
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: src/animation-loader.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AnimationLoader = /** @class */ (function () {
        /**
         * @param {?} ngZone
         * @param {?} platformId
         * @param {?} options
         * @param {?} animationCache
         */
        function AnimationLoader(ngZone, platformId, options, animationCache) {
            this.ngZone = ngZone;
            this.platformId = platformId;
            this.options = options;
            this.animationCache = animationCache;
            this.player$ = streamifyPlayerOrLoader(this.options.player);
        }
        /**
         * @param {?} options
         * @param {?} container
         * @param {?} eventsFacade
         * @param {?} animationCreated
         * @param {?} instance
         * @param {?} destroy$
         * @return {?}
         */
        AnimationLoader.prototype.resolveLoaderAndLoadAnimation = function (options, container, eventsFacade, animationCreated, instance, destroy$) {
            var _this = this;
            if (common.isPlatformServer(this.platformId)) {
                return;
            }
            this.player$.pipe(operators.takeUntil(destroy$)).subscribe(( /**
             * @param {?} player
             * @return {?}
             */function (/**
             * @param {?} player
             * @return {?}
             */ player) {
                /** @type {?} */
                var mergedOptions = mergeOptionsWithDefault(options, container, _this.animationCache);
                _this.loadAnimation(player, mergedOptions, eventsFacade, animationCreated, instance);
            }));
        };
        /**
         * @private
         * @param {?} player
         * @param {?} options
         * @param {?} eventsFacade
         * @param {?} animationCreated
         * @param {?} instance
         * @return {?}
         */
        AnimationLoader.prototype.loadAnimation = function (player, options, eventsFacade, animationCreated, instance) {
            /** @type {?} */
            var animationItem = this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () { return player.loadAnimation(( /** @type {?} */(options))); }));
            awaitConfigAndCache(this.animationCache, options, animationItem);
            // Dispatch `animationCreated` event after animation is loaded successfully
            animationCreated.emit(animationItem);
            eventsFacade.addEventListeners(instance, animationItem);
        };
        return AnimationLoader;
    }());
    AnimationLoader.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    AnimationLoader.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [LOTTIE_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [ANIMATION_CACHE,] }] }
    ]; };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        AnimationLoader.prototype.player$;
        /**
         * @type {?}
         * @private
         */
        AnimationLoader.prototype.ngZone;
        /**
         * @type {?}
         * @private
         */
        AnimationLoader.prototype.platformId;
        /**
         * @type {?}
         * @private
         */
        AnimationLoader.prototype.options;
        /**
         * @type {?}
         * @private
         */
        AnimationLoader.prototype.animationCache;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: src/base.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BaseDirective = /** @class */ (function () {
        /**
         * @param {?} platformId
         * @param {?} animationLoader
         */
        function BaseDirective(platformId, animationLoader) {
            this.platformId = platformId;
            this.animationLoader = animationLoader;
            this.options = null;
            this.containerClass = null;
            this.styles = null;
            /**
             * `animationCreated` is dispatched after calling `loadAnimation`
             */
            this.animationCreated = new i0.EventEmitter();
            /**
             * `complete` is dispatched after completing the last frame
             */
            this.complete = new i0.EventEmitter();
            /**
             * `loopComplete` is dispatched after completing frame loop
             */
            this.loopComplete = new i0.EventEmitter();
            /**
             * `enterFrame` is dispatched after entering the new frame
             */
            this.enterFrame = new i0.EventEmitter();
            /**
             * `segmentStart` is dispatched when the new segment is adjusted
             */
            this.segmentStart = new i0.EventEmitter();
            /**
             * Original event name is `config_ready`. `config_ready` is dispatched
             * after the needed renderer is configured
             */
            this.configReady = new i0.EventEmitter();
            /**
             * Original event name is `data_ready`. `data_ready` is dispatched
             * when all parts of the animation have been loaded
             */
            this.dataReady = new i0.EventEmitter();
            /**
             * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
             * when elements have been added to the DOM
             */
            this.domLoaded = new i0.EventEmitter();
            /**
             * `destroy` will be dispatched in the `ngOnDestroy` hook of the service,
             * it's useful for releasing resources
             */
            this.destroy = new i0.EventEmitter();
            /**
             * `error` will be dispatched if the lottie player could not render
             * some frame or parse config
             */
            this.error = new i0.EventEmitter();
            this.destroy$ = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        BaseDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
        };
        /**
         * @protected
         * @param {?} changes
         * @param {?} container
         * @param {?} eventsFacade
         * @param {?} instance
         * @return {?}
         */
        BaseDirective.prototype.loadAnimation = function (changes, container, eventsFacade, instance) {
            if (common.isPlatformServer(this.platformId) || !changes.options) {
                return;
            }
            eventsFacade.destroyAnimation();
            this.animationLoader.resolveLoaderAndLoadAnimation(changes.options.currentValue, container, eventsFacade, this.animationCreated, instance, this.destroy$);
        };
        return BaseDirective;
    }());
    BaseDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[lottie]' },] }
    ];
    /** @nocollapse */
    BaseDirective.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: AnimationLoader }
    ]; };
    BaseDirective.propDecorators = {
        options: [{ type: i0.Input }],
        containerClass: [{ type: i0.Input }],
        styles: [{ type: i0.Input }],
        animationCreated: [{ type: i0.Output }],
        complete: [{ type: i0.Output }],
        loopComplete: [{ type: i0.Output }],
        enterFrame: [{ type: i0.Output }],
        segmentStart: [{ type: i0.Output }],
        configReady: [{ type: i0.Output }],
        dataReady: [{ type: i0.Output }],
        domLoaded: [{ type: i0.Output }],
        destroy: [{ type: i0.Output }],
        error: [{ type: i0.Output }]
    };
    if (false) {
        /** @type {?} */
        BaseDirective.prototype.options;
        /** @type {?} */
        BaseDirective.prototype.containerClass;
        /** @type {?} */
        BaseDirective.prototype.styles;
        /**
         * `animationCreated` is dispatched after calling `loadAnimation`
         * @type {?}
         */
        BaseDirective.prototype.animationCreated;
        /**
         * `complete` is dispatched after completing the last frame
         * @type {?}
         */
        BaseDirective.prototype.complete;
        /**
         * `loopComplete` is dispatched after completing frame loop
         * @type {?}
         */
        BaseDirective.prototype.loopComplete;
        /**
         * `enterFrame` is dispatched after entering the new frame
         * @type {?}
         */
        BaseDirective.prototype.enterFrame;
        /**
         * `segmentStart` is dispatched when the new segment is adjusted
         * @type {?}
         */
        BaseDirective.prototype.segmentStart;
        /**
         * Original event name is `config_ready`. `config_ready` is dispatched
         * after the needed renderer is configured
         * @type {?}
         */
        BaseDirective.prototype.configReady;
        /**
         * Original event name is `data_ready`. `data_ready` is dispatched
         * when all parts of the animation have been loaded
         * @type {?}
         */
        BaseDirective.prototype.dataReady;
        /**
         * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
         * when elements have been added to the DOM
         * @type {?}
         */
        BaseDirective.prototype.domLoaded;
        /**
         * `destroy` will be dispatched in the `ngOnDestroy` hook of the service,
         * it's useful for releasing resources
         * @type {?}
         */
        BaseDirective.prototype.destroy;
        /**
         * `error` will be dispatched if the lottie player could not render
         * some frame or parse config
         * @type {?}
         */
        BaseDirective.prototype.error;
        /**
         * @type {?}
         * @private
         */
        BaseDirective.prototype.destroy$;
        /**
         * @type {?}
         * @private
         */
        BaseDirective.prototype.platformId;
        /**
         * @type {?}
         * @private
         */
        BaseDirective.prototype.animationLoader;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: src/animation-cache.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AnimationCache = /** @class */ (function () {
        function AnimationCache() {
            this.cache = new Map();
        }
        /**
         * @param {?} options
         * @return {?}
         */
        AnimationCache.create = function (options) {
            return options.useCache ? new AnimationCache() : null;
        };
        /**
         * @param {?} options
         * @return {?}
         */
        AnimationCache.prototype.transformOptions = function (options) {
            /** @type {?} */
            var path = (( /** @type {?} */(options))).path;
            if (path && this.cache.has(path)) {
                delete (( /** @type {?} */(options))).path;
                (( /** @type {?} */(options))).animationData = this.cache.get(path);
            }
            return options;
        };
        /**
         * @param {?} options
         * @param {?} animationItem
         * @return {?}
         */
        AnimationCache.prototype.set = function (options, animationItem) {
            /** @type {?} */
            var animationData = (( /** @type {?} */(options))).animationData;
            if (animationData) {
                return;
            }
            this.cache.set(( /** @type {?} */((( /** @type {?} */(options))).path)), animationItem['animationData']);
        };
        return AnimationCache;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        AnimationCache.prototype.cache;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, exports) {
        for (var p in m)
            if (p !== "default" && !exports.hasOwnProperty(p))
                __createBinding(exports, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * Returns only those `EventEmitter` instances that has attached observers
     * @param {?} instance
     * @param {?} eventsMap
     * @return {?}
     */
    function getObservedEventEmitters(instance, eventsMap) {
        return (Object.keys(instance)
            // `Object.entries` is not supported in IE11.
            .map(( /**
     * @param {?} key
     * @return {?}
     */function (/**
     * @param {?} key
     * @return {?}
     */ key) { return [key, instance[key]]; }))
            .filter(( /**
     * @param {?} __0
     * @return {?}
     */function (_a) {
            var _b = __read(_a, 2), key = _b[0], property = _b[1];
            return property instanceof i0.EventEmitter &&
                property.observers.length > 0 &&
                eventsMap.hasOwnProperty(key);
        }))
            .map(( /**
     * @param {?} __0
     * @return {?}
     */function (_a) {
            var _b = __read(_a, 2), key = _b[0], eventEmitter = _b[1];
            return ({
                eventEmitter: eventEmitter,
                name: eventsMap[key],
            });
        })));
    }
    var LottieEventsFacade = /** @class */ (function () {
        /**
         * @param {?} ngZone
         * @param {?} platformId
         */
        function LottieEventsFacade(ngZone, platformId) {
            this.ngZone = ngZone;
            this.platformId = platformId;
            /**
             * @see https://github.com/airbnb/lottie-web#events
             */
            this.eventsMap = {
                complete: 'complete',
                loopComplete: 'loopComplete',
                enterFrame: 'enterFrame',
                segmentStart: 'segmentStart',
                configReady: 'config_ready',
                dataReady: 'data_ready',
                domLoaded: 'DOMLoaded',
                destroy: 'destroy',
                error: 'error',
            };
            this.animationItem = null;
        }
        /**
         * @return {?}
         */
        LottieEventsFacade.prototype.ngOnDestroy = function () {
            this.destroyAnimation();
        };
        /**
         * @param {?} instance
         * @param {?} animationItem
         * @return {?}
         */
        LottieEventsFacade.prototype.addEventListeners = function (instance, animationItem) {
            var _this = this;
            this.animationItem = animationItem;
            // `AnimationItem` triggers different events every ms, we have to listen
            // them outside Angular's context, thus it won't affect performance
            this.ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () { return _this.addEventListenersToObservedEventEmitters(instance); }));
        };
        /**
         * @return {?}
         */
        LottieEventsFacade.prototype.destroyAnimation = function () {
            // The `ng-lottie` component or the `lottie` directive can be destroyed
            // before the `animationItem` is set, thus it will fail with
            // `Cannot read property 'destroy' of null`.
            // Potentially it can happen if the directive gets destroyed before change
            // detection is run.
            if (common.isPlatformServer(this.platformId) || this.animationItem === null) {
                return;
            }
            // `destroy()` will remove all events listeners
            this.animationItem.destroy();
            this.animationItem = null;
        };
        /**
         * @private
         * @param {?} instance
         * @return {?}
         */
        LottieEventsFacade.prototype.addEventListenersToObservedEventEmitters = function (instance) {
            var e_1, _a;
            /** @type {?} */
            var observedEmitters = getObservedEventEmitters(instance, this.eventsMap);
            var _loop_1 = function (name, eventEmitter) {
                ( /** @type {?} */(this_1.animationItem)).addEventListener(name, ( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    eventEmitter.emit(event);
                }));
            };
            var this_1 = this;
            try {
                for (var observedEmitters_1 = __values(observedEmitters), observedEmitters_1_1 = observedEmitters_1.next(); !observedEmitters_1_1.done; observedEmitters_1_1 = observedEmitters_1.next()) {
                    var _b = observedEmitters_1_1.value, name = _b.name, eventEmitter = _b.eventEmitter;
                    _loop_1(name, eventEmitter);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (observedEmitters_1_1 && !observedEmitters_1_1.done && (_a = observedEmitters_1.return)) _a.call(observedEmitters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return LottieEventsFacade;
    }());
    LottieEventsFacade.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    LottieEventsFacade.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    if (false) {
        /**
         * @see https://github.com/airbnb/lottie-web#events
         * @type {?}
         * @private
         */
        LottieEventsFacade.prototype.eventsMap;
        /**
         * @type {?}
         * @private
         */
        LottieEventsFacade.prototype.animationItem;
        /**
         * @type {?}
         * @private
         */
        LottieEventsFacade.prototype.ngZone;
        /**
         * @type {?}
         * @private
         */
        LottieEventsFacade.prototype.platformId;
    }

    var LottieDirective = /** @class */ (function (_super) {
        __extends(LottieDirective, _super);
        /**
         * @param {?} platformId
         * @param {?} host
         * @param {?} eventsFacade
         * @param {?} animationLoader
         */
        function LottieDirective(platformId, host, eventsFacade, animationLoader) {
            var _this = _super.call(this, platformId, animationLoader) || this;
            _this.host = host;
            _this.eventsFacade = eventsFacade;
            return _this;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LottieDirective.prototype.ngOnChanges = function (changes) {
            _super.prototype.loadAnimation.call(this, changes, this.host.nativeElement, this.eventsFacade, this);
        };
        return LottieDirective;
    }(BaseDirective));
    LottieDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[lottie]',
                    providers: [LottieEventsFacade],
                },] }
    ];
    /** @nocollapse */
    LottieDirective.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: i0.ElementRef, decorators: [{ type: i0.Self }] },
        { type: LottieEventsFacade, decorators: [{ type: i0.Self }] },
        { type: AnimationLoader }
    ]; };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        LottieDirective.prototype.host;
        /**
         * @type {?}
         * @private
         */
        LottieDirective.prototype.eventsFacade;
    }

    var LottieComponent = /** @class */ (function (_super) {
        __extends(LottieComponent, _super);
        /**
         * @param {?} platformId
         * @param {?} eventsFacade
         * @param {?} animationLoader
         */
        function LottieComponent(platformId, eventsFacade, animationLoader) {
            var _this = _super.call(this, platformId, animationLoader) || this;
            _this.eventsFacade = eventsFacade;
            _this.width = null;
            _this.height = null;
            _this.container = ( /** @type {?} */(null));
            return _this;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LottieComponent.prototype.ngOnChanges = function (changes) {
            _super.prototype.loadAnimation.call(this, changes, this.container.nativeElement, this.eventsFacade, this);
        };
        return LottieComponent;
    }(BaseDirective));
    LottieComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ng-lottie',
                    template: "\n    <div\n      #container\n      [style.width]=\"width || '100%'\"\n      [style.height]=\"height || '100%'\"\n      [ngStyle]=\"styles\"\n      [ngClass]=\"containerClass\"\n    ></div>\n  ",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    providers: [LottieEventsFacade]
                }] }
    ];
    /** @nocollapse */
    LottieComponent.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: LottieEventsFacade, decorators: [{ type: i0.Self }] },
        { type: AnimationLoader }
    ]; };
    LottieComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        container: [{ type: i0.ViewChild, args: ['container', { static: true },] }]
    };
    if (false) {
        /** @type {?} */
        LottieComponent.prototype.width;
        /** @type {?} */
        LottieComponent.prototype.height;
        /** @type {?} */
        LottieComponent.prototype.container;
        /**
         * @type {?}
         * @private
         */
        LottieComponent.prototype.eventsFacade;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: src/lottie.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LottieModule = /** @class */ (function () {
        function LottieModule() {
        }
        /**
         * @param {?} options
         * @return {?}
         */
        LottieModule.forRoot = function (options) {
            return {
                ngModule: LottieModule,
                providers: [
                    AnimationLoader,
                    {
                        provide: LOTTIE_OPTIONS,
                        useValue: options,
                    },
                    {
                        provide: ANIMATION_CACHE,
                        useFactory: AnimationCache.create,
                        deps: [LOTTIE_OPTIONS],
                    },
                ],
            };
        };
        return LottieModule;
    }());
    LottieModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [BaseDirective, LottieDirective, LottieComponent],
                    exports: [BaseDirective, LottieDirective, LottieComponent],
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: src/transfer-state.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LottieTransferState = /** @class */ (function () {
        /**
         * @param {?} transferState
         */
        function LottieTransferState(transferState) {
            this.transferState = transferState;
        }
        /**
         * @template T
         * @param {?} animation
         * @return {?}
         */
        LottieTransferState.prototype.get = function (animation) {
            /** @type {?} */
            var animationKey = transformAnimationFilenameToKey(animation);
            /** @type {?} */
            var stateKey = i1.makeStateKey(animationKey);
            return this.transferState.get(stateKey, null);
        };
        return LottieTransferState;
    }());
    LottieTransferState.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    LottieTransferState.ctorParameters = function () { return [
        { type: i1.TransferState }
    ]; };
    /** @nocollapse */ LottieTransferState.ɵprov = i0.ɵɵdefineInjectable({ factory: function LottieTransferState_Factory() { return new LottieTransferState(i0.ɵɵinject(i1.TransferState)); }, token: LottieTransferState, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        LottieTransferState.prototype.transferState;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: src/public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: ngx-lottie.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.BaseDirective = BaseDirective;
    exports.LottieComponent = LottieComponent;
    exports.LottieDirective = LottieDirective;
    exports.LottieModule = LottieModule;
    exports.LottieTransferState = LottieTransferState;
    exports.transformAnimationFilenameToKey = transformAnimationFilenameToKey;
    exports.ɵb = LOTTIE_OPTIONS;
    exports.ɵc = ANIMATION_CACHE;
    exports.ɵd = AnimationLoader;
    exports.ɵe = AnimationCache;
    exports.ɵf = LottieEventsFacade;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-lottie.umd.js.map
