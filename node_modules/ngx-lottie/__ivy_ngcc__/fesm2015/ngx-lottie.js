import { InjectionToken, Injectable, NgZone, Inject, PLATFORM_ID, EventEmitter, Directive, Input, Output, ElementRef, Self, Component, ChangeDetectionStrategy, ViewChild, NgModule, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import { isPlatformServer, CommonModule } from '@angular/common';
import { from, of, Subject } from 'rxjs';
import { map, publishReplay, refCount, takeUntil } from 'rxjs/operators';
import { makeStateKey, TransferState } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * Generated from: src/symbols.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/platform-browser';

const _c0 = ["container"];
function BMEnterFrameEvent() { }
if (false) {
    /** @type {?} */
    BMEnterFrameEvent.prototype.currentTime;
    /** @type {?} */
    BMEnterFrameEvent.prototype.duration;
    /** @type {?} */
    BMEnterFrameEvent.prototype.totalTime;
    /** @type {?} */
    BMEnterFrameEvent.prototype.type;
}
/**
 * @record
 */
function BMCompleteLoopEvent() { }
if (false) {
    /** @type {?} */
    BMCompleteLoopEvent.prototype.type;
    /** @type {?} */
    BMCompleteLoopEvent.prototype.loop;
    /** @type {?} */
    BMCompleteLoopEvent.prototype.playCount;
    /** @type {?} */
    BMCompleteLoopEvent.prototype.frameMult;
}
/**
 * @record
 */
function BMCompleteEvent() { }
if (false) {
    /** @type {?} */
    BMCompleteEvent.prototype.type;
    /** @type {?} */
    BMCompleteEvent.prototype.duration;
}
/**
 * @record
 */
function BMSegmentStartEvent() { }
if (false) {
    /** @type {?} */
    BMSegmentStartEvent.prototype.type;
    /** @type {?} */
    BMSegmentStartEvent.prototype.firstFrame;
    /** @type {?} */
    BMSegmentStartEvent.prototype.totalFrames;
}
/**
 * @record
 */
function BMDestroyEvent() { }
if (false) {
    /** @type {?} */
    BMDestroyEvent.prototype.target;
    /** @type {?} */
    BMDestroyEvent.prototype.type;
}
/**
 * @record
 */
function BMRenderFrameErrorEvent() { }
if (false) {
    /** @type {?} */
    BMRenderFrameErrorEvent.prototype.type;
    /** @type {?} */
    BMRenderFrameErrorEvent.prototype.nativeError;
    /** @type {?} */
    BMRenderFrameErrorEvent.prototype.currentTime;
}
/**
 * @record
 */
function BMConfigErrorEvent() { }
if (false) {
    /** @type {?} */
    BMConfigErrorEvent.prototype.type;
    /** @type {?} */
    BMConfigErrorEvent.prototype.nativeError;
}
/**
 * @record
 */
function LottieOptions() { }
if (false) {
    /** @type {?} */
    LottieOptions.prototype.player;
    /** @type {?|undefined} */
    LottieOptions.prototype.useCache;
}
/** @type {?} */
const LOTTIE_OPTIONS = new InjectionToken('LottieOptions');
/** @type {?} */
const ANIMATION_CACHE = new InjectionToken('AnimationCache');

/**
 * @fileoverview added by tsickle
 * Generated from: src/utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} animation
 * @return {?}
 */
function transformAnimationFilenameToKey(animation) {
    return `animation-${animation.split('.json')[0]}`;
}
/**
 * @param {?} options
 * @param {?} container
 * @param {?} animationCache
 * @return {?}
 */
function mergeOptionsWithDefault(options, container, animationCache) {
    /** @type {?} */
    const merged = Object.assign({
        container,
        renderer: 'svg',
        loop: true,
        autoplay: true,
    }, options);
    return animationCache !== null ? animationCache.transformOptions(merged) : merged;
}
/**
 * @param {?} animationCache
 * @param {?} options
 * @param {?} animationItem
 * @return {?}
 */
function awaitConfigAndCache(animationCache, options, animationItem) {
    if (animationCache === null) {
        return;
    }
    animationItem.addEventListener('config_ready', (/**
     * @return {?}
     */
    () => {
        animationCache.set(options, animationItem);
    }));
}
/**
 * @param {?} player
 * @return {?}
 */
function streamifyPlayerOrLoader(player) {
    /** @type {?} */
    const playerOrLoader = player();
    if (playerOrLoader instanceof Promise) {
        return from(playerOrLoader).pipe(map((/**
         * @param {?} module
         * @return {?}
         */
        module => module.default || module)), publishReplay(1), refCount());
    }
    else {
        return of(playerOrLoader);
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/animation-loader.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnimationLoader {
    /**
     * @param {?} ngZone
     * @param {?} platformId
     * @param {?} options
     * @param {?} animationCache
     */
    constructor(ngZone, platformId, options, animationCache) {
        this.ngZone = ngZone;
        this.platformId = platformId;
        this.options = options;
        this.animationCache = animationCache;
        this.player$ = streamifyPlayerOrLoader(this.options.player);
    }
    /**
     * @param {?} options
     * @param {?} container
     * @param {?} eventsFacade
     * @param {?} animationCreated
     * @param {?} instance
     * @param {?} destroy$
     * @return {?}
     */
    resolveLoaderAndLoadAnimation(options, container, eventsFacade, animationCreated, instance, destroy$) {
        if (isPlatformServer(this.platformId)) {
            return;
        }
        this.player$.pipe(takeUntil(destroy$)).subscribe((/**
         * @param {?} player
         * @return {?}
         */
        player => {
            /** @type {?} */
            const mergedOptions = mergeOptionsWithDefault(options, container, this.animationCache);
            this.loadAnimation(player, mergedOptions, eventsFacade, animationCreated, instance);
        }));
    }
    /**
     * @private
     * @param {?} player
     * @param {?} options
     * @param {?} eventsFacade
     * @param {?} animationCreated
     * @param {?} instance
     * @return {?}
     */
    loadAnimation(player, options, eventsFacade, animationCreated, instance) {
        /** @type {?} */
        const animationItem = this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => player.loadAnimation((/** @type {?} */ (options)))));
        awaitConfigAndCache(this.animationCache, options, animationItem);
        // Dispatch `animationCreated` event after animation is loaded successfully
        animationCreated.emit(animationItem);
        eventsFacade.addEventListeners(instance, animationItem);
    }
}
AnimationLoader.ɵfac = function AnimationLoader_Factory(t) { return new (t || AnimationLoader)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(LOTTIE_OPTIONS), ɵngcc0.ɵɵinject(ANIMATION_CACHE)); };
AnimationLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AnimationLoader, factory: AnimationLoader.ɵfac });
/** @nocollapse */
AnimationLoader.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOTTIE_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [ANIMATION_CACHE,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AnimationLoader, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [LOTTIE_OPTIONS]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [ANIMATION_CACHE]
            }] }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.player$;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.options;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.animationCache;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/base.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BaseDirective {
    /**
     * @param {?} platformId
     * @param {?} animationLoader
     */
    constructor(platformId, animationLoader) {
        this.platformId = platformId;
        this.animationLoader = animationLoader;
        this.options = null;
        this.containerClass = null;
        this.styles = null;
        /**
         * `animationCreated` is dispatched after calling `loadAnimation`
         */
        this.animationCreated = new EventEmitter();
        /**
         * `complete` is dispatched after completing the last frame
         */
        this.complete = new EventEmitter();
        /**
         * `loopComplete` is dispatched after completing frame loop
         */
        this.loopComplete = new EventEmitter();
        /**
         * `enterFrame` is dispatched after entering the new frame
         */
        this.enterFrame = new EventEmitter();
        /**
         * `segmentStart` is dispatched when the new segment is adjusted
         */
        this.segmentStart = new EventEmitter();
        /**
         * Original event name is `config_ready`. `config_ready` is dispatched
         * after the needed renderer is configured
         */
        this.configReady = new EventEmitter();
        /**
         * Original event name is `data_ready`. `data_ready` is dispatched
         * when all parts of the animation have been loaded
         */
        this.dataReady = new EventEmitter();
        /**
         * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
         * when elements have been added to the DOM
         */
        this.domLoaded = new EventEmitter();
        /**
         * `destroy` will be dispatched in the `ngOnDestroy` hook of the service,
         * it's useful for releasing resources
         */
        this.destroy = new EventEmitter();
        /**
         * `error` will be dispatched if the lottie player could not render
         * some frame or parse config
         */
        this.error = new EventEmitter();
        this.destroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @protected
     * @param {?} changes
     * @param {?} container
     * @param {?} eventsFacade
     * @param {?} instance
     * @return {?}
     */
    loadAnimation(changes, container, eventsFacade, instance) {
        if (isPlatformServer(this.platformId) || !changes.options) {
            return;
        }
        eventsFacade.destroyAnimation();
        this.animationLoader.resolveLoaderAndLoadAnimation(changes.options.currentValue, container, eventsFacade, this.animationCreated, instance, this.destroy$);
    }
}
BaseDirective.ɵfac = function BaseDirective_Factory(t) { return new (t || BaseDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(AnimationLoader)); };
BaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseDirective, selectors: [["", "lottie", ""]], inputs: { options: "options", containerClass: "containerClass", styles: "styles" }, outputs: { animationCreated: "animationCreated", complete: "complete", loopComplete: "loopComplete", enterFrame: "enterFrame", segmentStart: "segmentStart", configReady: "configReady", dataReady: "dataReady", domLoaded: "domLoaded", destroy: "destroy", error: "error" } });
/** @nocollapse */
BaseDirective.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: AnimationLoader }
];
BaseDirective.propDecorators = {
    options: [{ type: Input }],
    containerClass: [{ type: Input }],
    styles: [{ type: Input }],
    animationCreated: [{ type: Output }],
    complete: [{ type: Output }],
    loopComplete: [{ type: Output }],
    enterFrame: [{ type: Output }],
    segmentStart: [{ type: Output }],
    configReady: [{ type: Output }],
    dataReady: [{ type: Output }],
    domLoaded: [{ type: Output }],
    destroy: [{ type: Output }],
    error: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseDirective, [{
        type: Directive,
        args: [{ selector: '[lottie]' }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: AnimationLoader }]; }, { options: [{
            type: Input
        }], containerClass: [{
            type: Input
        }], styles: [{
            type: Input
        }], animationCreated: [{
            type: Output
        }], complete: [{
            type: Output
        }], loopComplete: [{
            type: Output
        }], enterFrame: [{
            type: Output
        }], segmentStart: [{
            type: Output
        }], configReady: [{
            type: Output
        }], dataReady: [{
            type: Output
        }], domLoaded: [{
            type: Output
        }], destroy: [{
            type: Output
        }], error: [{
            type: Output
        }] }); })();
if (false) {
    /** @type {?} */
    BaseDirective.prototype.options;
    /** @type {?} */
    BaseDirective.prototype.containerClass;
    /** @type {?} */
    BaseDirective.prototype.styles;
    /**
     * `animationCreated` is dispatched after calling `loadAnimation`
     * @type {?}
     */
    BaseDirective.prototype.animationCreated;
    /**
     * `complete` is dispatched after completing the last frame
     * @type {?}
     */
    BaseDirective.prototype.complete;
    /**
     * `loopComplete` is dispatched after completing frame loop
     * @type {?}
     */
    BaseDirective.prototype.loopComplete;
    /**
     * `enterFrame` is dispatched after entering the new frame
     * @type {?}
     */
    BaseDirective.prototype.enterFrame;
    /**
     * `segmentStart` is dispatched when the new segment is adjusted
     * @type {?}
     */
    BaseDirective.prototype.segmentStart;
    /**
     * Original event name is `config_ready`. `config_ready` is dispatched
     * after the needed renderer is configured
     * @type {?}
     */
    BaseDirective.prototype.configReady;
    /**
     * Original event name is `data_ready`. `data_ready` is dispatched
     * when all parts of the animation have been loaded
     * @type {?}
     */
    BaseDirective.prototype.dataReady;
    /**
     * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
     * when elements have been added to the DOM
     * @type {?}
     */
    BaseDirective.prototype.domLoaded;
    /**
     * `destroy` will be dispatched in the `ngOnDestroy` hook of the service,
     * it's useful for releasing resources
     * @type {?}
     */
    BaseDirective.prototype.destroy;
    /**
     * `error` will be dispatched if the lottie player could not render
     * some frame or parse config
     * @type {?}
     */
    BaseDirective.prototype.error;
    /**
     * @type {?}
     * @private
     */
    BaseDirective.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    BaseDirective.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    BaseDirective.prototype.animationLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/animation-cache.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnimationCache {
    constructor() {
        this.cache = new Map();
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static create(options) {
        return options.useCache ? new AnimationCache() : null;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    transformOptions(options) {
        /** @type {?} */
        const path = ((/** @type {?} */ (options))).path;
        if (path && this.cache.has(path)) {
            delete ((/** @type {?} */ (options))).path;
            ((/** @type {?} */ (options))).animationData = this.cache.get(path);
        }
        return options;
    }
    /**
     * @param {?} options
     * @param {?} animationItem
     * @return {?}
     */
    set(options, animationItem) {
        /** @type {?} */
        const animationData = ((/** @type {?} */ (options))).animationData;
        if (animationData) {
            return;
        }
        this.cache.set((/** @type {?} */ (((/** @type {?} */ (options))).path)), animationItem['animationData']);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    AnimationCache.prototype.cache;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/events-facade.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns only those `EventEmitter` instances that has attached observers
 * @param {?} instance
 * @param {?} eventsMap
 * @return {?}
 */
function getObservedEventEmitters(instance, eventsMap) {
    return (Object.keys(instance)
        // `Object.entries` is not supported in IE11.
        .map((/**
     * @param {?} key
     * @return {?}
     */
    key => [key, instance[key]]))
        .filter((/**
     * @param {?} __0
     * @return {?}
     */
    ([key, property]) => property instanceof EventEmitter &&
        property.observers.length > 0 &&
        eventsMap.hasOwnProperty(key)))
        .map((/**
     * @param {?} __0
     * @return {?}
     */
    ([key, eventEmitter]) => ({
        eventEmitter,
        name: eventsMap[key],
    }))));
}
class LottieEventsFacade {
    /**
     * @param {?} ngZone
     * @param {?} platformId
     */
    constructor(ngZone, platformId) {
        this.ngZone = ngZone;
        this.platformId = platformId;
        /**
         * @see https://github.com/airbnb/lottie-web#events
         */
        this.eventsMap = {
            complete: 'complete',
            loopComplete: 'loopComplete',
            enterFrame: 'enterFrame',
            segmentStart: 'segmentStart',
            configReady: 'config_ready',
            dataReady: 'data_ready',
            domLoaded: 'DOMLoaded',
            destroy: 'destroy',
            error: 'error',
        };
        this.animationItem = null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyAnimation();
    }
    /**
     * @param {?} instance
     * @param {?} animationItem
     * @return {?}
     */
    addEventListeners(instance, animationItem) {
        this.animationItem = animationItem;
        // `AnimationItem` triggers different events every ms, we have to listen
        // them outside Angular's context, thus it won't affect performance
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => this.addEventListenersToObservedEventEmitters(instance)));
    }
    /**
     * @return {?}
     */
    destroyAnimation() {
        // The `ng-lottie` component or the `lottie` directive can be destroyed
        // before the `animationItem` is set, thus it will fail with
        // `Cannot read property 'destroy' of null`.
        // Potentially it can happen if the directive gets destroyed before change
        // detection is run.
        if (isPlatformServer(this.platformId) || this.animationItem === null) {
            return;
        }
        // `destroy()` will remove all events listeners
        this.animationItem.destroy();
        this.animationItem = null;
    }
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    addEventListenersToObservedEventEmitters(instance) {
        /** @type {?} */
        const observedEmitters = getObservedEventEmitters(instance, this.eventsMap);
        for (const { name, eventEmitter } of observedEmitters) {
            (/** @type {?} */ (this.animationItem)).addEventListener(name, (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                eventEmitter.emit(event);
            }));
        }
    }
}
LottieEventsFacade.ɵfac = function LottieEventsFacade_Factory(t) { return new (t || LottieEventsFacade)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PLATFORM_ID)); };
LottieEventsFacade.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LottieEventsFacade, factory: LottieEventsFacade.ɵfac });
/** @nocollapse */
LottieEventsFacade.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LottieEventsFacade, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, null); })();
if (false) {
    /**
     * @see https://github.com/airbnb/lottie-web#events
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.eventsMap;
    /**
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.animationItem;
    /**
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/lottie.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LottieDirective extends BaseDirective {
    /**
     * @param {?} platformId
     * @param {?} host
     * @param {?} eventsFacade
     * @param {?} animationLoader
     */
    constructor(platformId, host, eventsFacade, animationLoader) {
        super(platformId, animationLoader);
        this.host = host;
        this.eventsFacade = eventsFacade;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.loadAnimation(changes, this.host.nativeElement, this.eventsFacade, this);
    }
}
LottieDirective.ɵfac = function LottieDirective_Factory(t) { return new (t || LottieDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef, 2), ɵngcc0.ɵɵdirectiveInject(LottieEventsFacade, 2), ɵngcc0.ɵɵdirectiveInject(AnimationLoader)); };
LottieDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LottieDirective, selectors: [["", "lottie", ""]], features: [ɵngcc0.ɵɵProvidersFeature([LottieEventsFacade]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
LottieDirective.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef, decorators: [{ type: Self }] },
    { type: LottieEventsFacade, decorators: [{ type: Self }] },
    { type: AnimationLoader }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LottieDirective, [{
        type: Directive,
        args: [{
                selector: '[lottie]',
                providers: [LottieEventsFacade]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef, decorators: [{
                type: Self
            }] }, { type: LottieEventsFacade, decorators: [{
                type: Self
            }] }, { type: AnimationLoader }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    LottieDirective.prototype.host;
    /**
     * @type {?}
     * @private
     */
    LottieDirective.prototype.eventsFacade;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/lottie.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LottieComponent extends BaseDirective {
    /**
     * @param {?} platformId
     * @param {?} eventsFacade
     * @param {?} animationLoader
     */
    constructor(platformId, eventsFacade, animationLoader) {
        super(platformId, animationLoader);
        this.eventsFacade = eventsFacade;
        this.width = null;
        this.height = null;
        this.container = (/** @type {?} */ (null));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.loadAnimation(changes, this.container.nativeElement, this.eventsFacade, this);
    }
}
LottieComponent.ɵfac = function LottieComponent_Factory(t) { return new (t || LottieComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(LottieEventsFacade, 2), ɵngcc0.ɵɵdirectiveInject(AnimationLoader)); };
LottieComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LottieComponent, selectors: [["ng-lottie"]], viewQuery: function LottieComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
    } }, inputs: { width: "width", height: "height" }, features: [ɵngcc0.ɵɵProvidersFeature([LottieEventsFacade]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 6, consts: [[3, "ngStyle", "ngClass"], ["container", ""]], template: function LottieComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width || "100%")("height", ctx.height || "100%");
        ɵngcc0.ɵɵproperty("ngStyle", ctx.styles)("ngClass", ctx.containerClass);
    } }, directives: [ɵngcc1.NgStyle, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
LottieComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: LottieEventsFacade, decorators: [{ type: Self }] },
    { type: AnimationLoader }
];
LottieComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LottieComponent, [{
        type: Component,
        args: [{
                selector: 'ng-lottie',
                template: `
    <div
      #container
      [style.width]="width || '100%'"
      [style.height]="height || '100%'"
      [ngStyle]="styles"
      [ngClass]="containerClass"
    ></div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [LottieEventsFacade]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: LottieEventsFacade, decorators: [{
                type: Self
            }] }, { type: AnimationLoader }]; }, { width: [{
            type: Input
        }], height: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    LottieComponent.prototype.width;
    /** @type {?} */
    LottieComponent.prototype.height;
    /** @type {?} */
    LottieComponent.prototype.container;
    /**
     * @type {?}
     * @private
     */
    LottieComponent.prototype.eventsFacade;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/lottie.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LottieModule {
    /**
     * @param {?} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: LottieModule,
            providers: [
                AnimationLoader,
                {
                    provide: LOTTIE_OPTIONS,
                    useValue: options,
                },
                {
                    provide: ANIMATION_CACHE,
                    useFactory: AnimationCache.create,
                    deps: [LOTTIE_OPTIONS],
                },
            ],
        };
    }
}
LottieModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LottieModule });
LottieModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LottieModule_Factory(t) { return new (t || LottieModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LottieModule, { declarations: function () { return [BaseDirective, LottieDirective, LottieComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [BaseDirective, LottieDirective, LottieComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LottieModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [BaseDirective, LottieDirective, LottieComponent],
                exports: [BaseDirective, LottieDirective, LottieComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: src/transfer-state.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LottieTransferState {
    /**
     * @param {?} transferState
     */
    constructor(transferState) {
        this.transferState = transferState;
    }
    /**
     * @template T
     * @param {?} animation
     * @return {?}
     */
    get(animation) {
        /** @type {?} */
        const animationKey = transformAnimationFilenameToKey(animation);
        /** @type {?} */
        const stateKey = makeStateKey(animationKey);
        return this.transferState.get(stateKey, null);
    }
}
LottieTransferState.ɵfac = function LottieTransferState_Factory(t) { return new (t || LottieTransferState)(ɵngcc0.ɵɵinject(ɵngcc2.TransferState)); };
/** @nocollapse */
LottieTransferState.ctorParameters = () => [
    { type: TransferState }
];
/** @nocollapse */ LottieTransferState.ɵprov = ɵɵdefineInjectable({ factory: function LottieTransferState_Factory() { return new LottieTransferState(ɵɵinject(TransferState)); }, token: LottieTransferState, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LottieTransferState, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc2.TransferState }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    LottieTransferState.prototype.transferState;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-lottie.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BaseDirective, LottieComponent, LottieDirective, LottieModule, LottieTransferState, transformAnimationFilenameToKey, LOTTIE_OPTIONS as ɵb, ANIMATION_CACHE as ɵc, AnimationLoader as ɵd, AnimationCache as ɵe, LottieEventsFacade as ɵf };

//# sourceMappingURL=ngx-lottie.js.map