/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, InjectionToken, NgModule, NgZone, Optional, PLATFORM_ID, VERSION as NG_VERSION, Version } from '@angular/core';
import * as firebase from 'firebase/app';
/**
 * @record
 */
export function FirebaseOptions() { }
/**
 * @record
 */
export function FirebaseAppConfig() { }
/** @type {?} */
export const FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');
/** @type {?} */
export const FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');
// Have to implement as we need to return a class from the provider, we should consider exporting
// this in the firebase/app types as this is our highest risk of breaks
export class FirebaseApp {
}
if (false) {
    /** @type {?} */
    FirebaseApp.prototype.name;
    /** @type {?} */
    FirebaseApp.prototype.options;
    /** @type {?} */
    FirebaseApp.prototype.analytics;
    /** @type {?} */
    FirebaseApp.prototype.auth;
    /** @type {?} */
    FirebaseApp.prototype.database;
    /** @type {?} */
    FirebaseApp.prototype.messaging;
    /** @type {?} */
    FirebaseApp.prototype.performance;
    /** @type {?} */
    FirebaseApp.prototype.storage;
    /** @type {?} */
    FirebaseApp.prototype.delete;
    /** @type {?} */
    FirebaseApp.prototype.firestore;
    /** @type {?} */
    FirebaseApp.prototype.functions;
    /** @type {?} */
    FirebaseApp.prototype.remoteConfig;
}
/** @type {?} */
export const VERSION = new Version('6.0.2');
/**
 * @param {?} options
 * @param {?} zone
 * @param {?=} nameOrConfig
 * @return {?}
 */
export function ɵfirebaseAppFactory(options, zone, nameOrConfig) {
    /** @type {?} */
    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';
    /** @type {?} */
    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};
    config.name = config.name || name;
    // Added any due to some inconsistency between @firebase/app and firebase types
    /** @type {?} */
    const existingApp = (/** @type {?} */ (firebase.apps.filter((/**
     * @param {?} app
     * @return {?}
     */
    app => app && app.name === config.name))[0]));
    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any
    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206
    return (/** @type {?} */ ((existingApp || zone.runOutsideAngular((/**
     * @return {?}
     */
    () => firebase.initializeApp(options, (/** @type {?} */ (config))))))));
}
/** @type {?} */
const FIREBASE_APP_PROVIDER = {
    provide: FirebaseApp,
    useFactory: ɵfirebaseAppFactory,
    deps: [
        FIREBASE_OPTIONS,
        NgZone,
        [new Optional(), FIREBASE_APP_NAME]
    ]
};
export class AngularFireModule {
    // tslint:disable-next-line:ban-types
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        firebase.registerVersion('angularfire', VERSION.full, platformId.toString());
        firebase.registerVersion('angular', NG_VERSION.full);
    }
    /**
     * @param {?} options
     * @param {?=} nameOrConfig
     * @return {?}
     */
    static initializeApp(options, nameOrConfig) {
        return {
            ngModule: AngularFireModule,
            providers: [
                { provide: FIREBASE_OPTIONS, useValue: options },
                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }
            ]
        };
    }
}
AngularFireModule.decorators = [
    { type: NgModule, args: [{
                providers: [FIREBASE_APP_PROVIDER]
            },] }
];
/** @nocollapse */
AngularFireModule.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZWJhc2UuYXBwLm1vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2ZpcmViYXNlLmFwcC5tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxPQUFPLElBQUksVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoSSxPQUFPLEtBQUssUUFBUSxNQUFNLGNBQWMsQ0FBQzs7OztBQUl6QyxxQ0FFQzs7OztBQUVELHVDQUVDOztBQUVELE1BQU0sT0FBTyxnQkFBZ0IsR0FBRyxJQUFJLGNBQWMsQ0FBa0IsMEJBQTBCLENBQUM7O0FBQy9GLE1BQU0sT0FBTyxpQkFBaUIsR0FBRyxJQUFJLGNBQWMsQ0FBeUMsK0JBQStCLENBQUM7OztBQUk1SCxNQUFNLE9BQU8sV0FBVztDQWF2Qjs7O0lBWkMsMkJBQWE7O0lBQ2IsOEJBQVk7O0lBQ1osZ0NBQXFDOztJQUNyQywyQkFBc0I7O0lBQ3RCLCtCQUFzRDs7SUFDdEQsZ0NBQXFDOztJQUNyQyxrQ0FBMkM7O0lBQzNDLDhCQUFxRDs7SUFDckQsNkJBQTRCOztJQUM1QixnQ0FBcUM7O0lBQ3JDLGdDQUFvRDs7SUFDcEQsbUNBQThDOzs7QUFHaEQsTUFBTSxPQUFPLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQzs7Ozs7OztBQUUxRCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsT0FBd0IsRUFBRSxJQUFZLEVBQUUsWUFBZ0Q7O1VBQ3BILElBQUksR0FBRyxPQUFPLFlBQVksS0FBSyxRQUFRLElBQUksWUFBWSxJQUFJLFdBQVc7O1VBQ3RFLE1BQU0sR0FBRyxPQUFPLFlBQVksS0FBSyxRQUFRLElBQUksWUFBWSxJQUFJLEVBQUU7SUFDckUsTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQzs7O1VBRTVCLFdBQVcsR0FBRyxtQkFBQSxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU07Ozs7SUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLENBQUMsRUFBTztJQUMxRixrR0FBa0c7SUFDbEcsNkVBQTZFO0lBQzdFLE9BQU8sbUJBQUEsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLGlCQUFpQjs7O0lBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsbUJBQUEsTUFBTSxFQUFPLENBQUMsRUFBQyxDQUFDLEVBQWUsQ0FBQztBQUN0SCxDQUFDOztNQUVLLHFCQUFxQixHQUFHO0lBQzVCLE9BQU8sRUFBRSxXQUFXO0lBQ3BCLFVBQVUsRUFBRSxtQkFBbUI7SUFDL0IsSUFBSSxFQUFFO1FBQ0osZ0JBQWdCO1FBQ2hCLE1BQU07UUFDTixDQUFDLElBQUksUUFBUSxFQUFFLEVBQUUsaUJBQWlCLENBQUM7S0FDcEM7Q0FDRjtBQUtELE1BQU0sT0FBTyxpQkFBaUI7Ozs7O0lBWTVCLFlBQWlDLFVBQWtCO1FBQ2pELFFBQVEsQ0FBQyxlQUFlLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDN0UsUUFBUSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7Ozs7OztJQWRELE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBd0IsRUFBRSxZQUF5QztRQUN0RixPQUFPO1lBQ0wsUUFBUSxFQUFFLGlCQUFpQjtZQUMzQixTQUFTLEVBQUU7Z0JBQ1QsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtnQkFDaEQsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRTthQUN2RDtTQUNGLENBQUM7SUFDSixDQUFDOzs7WUFaRixRQUFRLFNBQUM7Z0JBQ1IsU0FBUyxFQUFFLENBQUMscUJBQXFCLENBQUM7YUFDbkM7Ozs7WUFhOEMsTUFBTSx1QkFBdEMsTUFBTSxTQUFDLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGlvblRva2VuLCBOZ01vZHVsZSwgTmdab25lLCBPcHRpb25hbCwgUExBVEZPUk1fSUQsIFZFUlNJT04gYXMgTkdfVkVSU0lPTiwgVmVyc2lvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IGFuYWx5dGljcywgYXBwLCBhdXRoLCBkYXRhYmFzZSwgZmlyZXN0b3JlLCBmdW5jdGlvbnMsIG1lc3NhZ2luZywgcGVyZm9ybWFuY2UsIHJlbW90ZUNvbmZpZywgc3RvcmFnZSB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5cbi8vIElOVkVTVElHQVRFIFB1YmxpYyB0eXBlcyBkb24ndCBleHBvc2UgRmlyZWJhc2VPcHRpb25zIG9yIEZpcmViYXNlQXBwQ29uZmlnLCBpcyB0aGlzIHRoZSBjYXNlIGFueWxvbmdlcj9cbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VPcHRpb25zIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpcmViYXNlQXBwQ29uZmlnIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgY29uc3QgRklSRUJBU0VfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxGaXJlYmFzZU9wdGlvbnM+KCdhbmd1bGFyZmlyZTIuYXBwLm9wdGlvbnMnKTtcbmV4cG9ydCBjb25zdCBGSVJFQkFTRV9BUFBfTkFNRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmcgfCBGaXJlYmFzZUFwcENvbmZpZyB8IHVuZGVmaW5lZD4oJ2FuZ3VsYXJmaXJlMi5hcHAubmFtZU9yQ29uZmlnJyk7XG5cbi8vIEhhdmUgdG8gaW1wbGVtZW50IGFzIHdlIG5lZWQgdG8gcmV0dXJuIGEgY2xhc3MgZnJvbSB0aGUgcHJvdmlkZXIsIHdlIHNob3VsZCBjb25zaWRlciBleHBvcnRpbmdcbi8vIHRoaXMgaW4gdGhlIGZpcmViYXNlL2FwcCB0eXBlcyBhcyB0aGlzIGlzIG91ciBoaWdoZXN0IHJpc2sgb2YgYnJlYWtzXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VBcHAgaW1wbGVtZW50cyBQYXJ0aWFsPGFwcC5BcHA+IHtcbiAgbmFtZTogc3RyaW5nO1xuICBvcHRpb25zOiB7fTtcbiAgYW5hbHl0aWNzOiAoKSA9PiBhbmFseXRpY3MuQW5hbHl0aWNzO1xuICBhdXRoOiAoKSA9PiBhdXRoLkF1dGg7XG4gIGRhdGFiYXNlOiAoZGF0YWJhc2VVUkw/OiBzdHJpbmcpID0+IGRhdGFiYXNlLkRhdGFiYXNlO1xuICBtZXNzYWdpbmc6ICgpID0+IG1lc3NhZ2luZy5NZXNzYWdpbmc7XG4gIHBlcmZvcm1hbmNlOiAoKSA9PiBwZXJmb3JtYW5jZS5QZXJmb3JtYW5jZTtcbiAgc3RvcmFnZTogKHN0b3JhZ2VCdWNrZXQ/OiBzdHJpbmcpID0+IHN0b3JhZ2UuU3RvcmFnZTtcbiAgZGVsZXRlOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBmaXJlc3RvcmU6ICgpID0+IGZpcmVzdG9yZS5GaXJlc3RvcmU7XG4gIGZ1bmN0aW9uczogKHJlZ2lvbj86IHN0cmluZykgPT4gZnVuY3Rpb25zLkZ1bmN0aW9ucztcbiAgcmVtb3RlQ29uZmlnOiAoKSA9PiByZW1vdGVDb25maWcuUmVtb3RlQ29uZmlnO1xufVxuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IG5ldyBWZXJzaW9uKCdBTkdVTEFSRklSRTJfVkVSU0lPTicpO1xuXG5leHBvcnQgZnVuY3Rpb24gybVmaXJlYmFzZUFwcEZhY3Rvcnkob3B0aW9uczogRmlyZWJhc2VPcHRpb25zLCB6b25lOiBOZ1pvbmUsIG5hbWVPckNvbmZpZz86IHN0cmluZyB8IEZpcmViYXNlQXBwQ29uZmlnIHwgbnVsbCkge1xuICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckNvbmZpZyA9PT0gJ3N0cmluZycgJiYgbmFtZU9yQ29uZmlnIHx8ICdbREVGQVVMVF0nO1xuICBjb25zdCBjb25maWcgPSB0eXBlb2YgbmFtZU9yQ29uZmlnID09PSAnb2JqZWN0JyAmJiBuYW1lT3JDb25maWcgfHwge307XG4gIGNvbmZpZy5uYW1lID0gY29uZmlnLm5hbWUgfHwgbmFtZTtcbiAgLy8gQWRkZWQgYW55IGR1ZSB0byBzb21lIGluY29uc2lzdGVuY3kgYmV0d2VlbiBAZmlyZWJhc2UvYXBwIGFuZCBmaXJlYmFzZSB0eXBlc1xuICBjb25zdCBleGlzdGluZ0FwcCA9IGZpcmViYXNlLmFwcHMuZmlsdGVyKGFwcCA9PiBhcHAgJiYgYXBwLm5hbWUgPT09IGNvbmZpZy5uYW1lKVswXSBhcyBhbnk7XG4gIC8vIFdlIHN1cHBvcnQgRmlyZWJhc2VDb25maWcsIGluaXRpYWxpemVBcHAncyBwdWJsaWMgdHlwZSBvbmx5IGFjY2VwdHMgc3RyaW5nOyBuZWVkIHRvIGNhc3QgYXMgYW55XG4gIC8vIENvdWxkIGJlIHNvbHZlZCB3aXRoIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvcHVsbC8xMjA2XG4gIHJldHVybiAoZXhpc3RpbmdBcHAgfHwgem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBmaXJlYmFzZS5pbml0aWFsaXplQXBwKG9wdGlvbnMsIGNvbmZpZyBhcyBhbnkpKSkgYXMgRmlyZWJhc2VBcHA7XG59XG5cbmNvbnN0IEZJUkVCQVNFX0FQUF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogRmlyZWJhc2VBcHAsXG4gIHVzZUZhY3Rvcnk6IMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICBkZXBzOiBbXG4gICAgRklSRUJBU0VfT1BUSU9OUyxcbiAgICBOZ1pvbmUsXG4gICAgW25ldyBPcHRpb25hbCgpLCBGSVJFQkFTRV9BUFBfTkFNRV1cbiAgXVxufTtcblxuQE5nTW9kdWxlKHtcbiAgcHJvdmlkZXJzOiBbRklSRUJBU0VfQVBQX1BST1ZJREVSXVxufSlcbmV4cG9ydCBjbGFzcyBBbmd1bGFyRmlyZU1vZHVsZSB7XG4gIHN0YXRpYyBpbml0aWFsaXplQXBwKG9wdGlvbnM6IEZpcmViYXNlT3B0aW9ucywgbmFtZU9yQ29uZmlnPzogc3RyaW5nIHwgRmlyZWJhc2VBcHBDb25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IEFuZ3VsYXJGaXJlTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogRklSRUJBU0VfT1BUSU9OUywgdXNlVmFsdWU6IG9wdGlvbnMgfSxcbiAgICAgICAgeyBwcm92aWRlOiBGSVJFQkFTRV9BUFBfTkFNRSwgdXNlVmFsdWU6IG5hbWVPckNvbmZpZyB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbiAgY29uc3RydWN0b3IoQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0KSB7XG4gICAgZmlyZWJhc2UucmVnaXN0ZXJWZXJzaW9uKCdhbmd1bGFyZmlyZScsIFZFUlNJT04uZnVsbCwgcGxhdGZvcm1JZC50b1N0cmluZygpKTtcbiAgICBmaXJlYmFzZS5yZWdpc3RlclZlcnNpb24oJ2FuZ3VsYXInLCBOR19WRVJTSU9OLmZ1bGwpO1xuICB9XG59XG4iXX0=