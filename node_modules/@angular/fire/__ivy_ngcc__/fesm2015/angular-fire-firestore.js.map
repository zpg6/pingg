{"version":3,"file":"angular-fire-firestore.js","sources":["../../../src/firestore/observable/fromRef.ts","../../../src/firestore/collection/changes.ts","../../../src/firestore/collection/collection.ts","../../../src/firestore/document/document.ts","../../../src/firestore/collection-group/collection-group.ts","../../../src/firestore/firestore.ts","../../../src/firestore/firestore.module.ts","../../../src/firestore/interfaces.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAIA,SAAS,QAAQ,CAAO,GAAiB,EAAE,YAA2B,cAAc;AAAI,IACtF,OAAO,IAAI,UAAU;AAAM;AACX;AACF;AAAQ,IAFA,UAAU;AAClC;AACI,YADI,WAAW;AACnB,QAAI,IAAI,SAAS,IAAI,IAAI,EAAE;AAC3B,YAAM,SAAS,CAAC,QAAQ;AAAM;AACN;AAAgB,YADf;AACzB,gBAAQ,WAAW,GAAG,GAAG,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AACjD,aAAO,EAAC,CAAC;AACT,SAAK;AAAC,aAAK;AACX,YAAM,WAAW,GAAG,GAAG,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AAC/C,SAAK;AACL,QACI;AAAY;AACI;AAAY,QADrB;AACX,YAAM,IAAI,WAAW,IAAI,IAAI,EAAE;AAC/B,gBAAQ,WAAW,EAAE,CAAC;AACtB,aAAO;AACP,SAAK,EAAC;AACN,KAAG,EAAC,CAAC;AACL,CAAC;AACD;AACG;AAAe;AAAkB;AAAyB;AAAe;AAAI,SAAhE,OAAO,CAAI,GAA8B,EAAE,SAAyB;AACpF,IAAE,OAAO,QAAQ,CAAgB,GAAG,EAAE,SAAS,CAAC,CAAC;AACjD,CAAC;AACD;AACG;AAAe;AAAkB;AAAyB;AAAe;AAAI,SAAhE,UAAU,CAAI,GAAsB,EAAE,SAAyB;AAAI,IACjF,OAAO,OAAO,CAAsB,GAAG,EAAE,SAAS,CAAC;AACrD,SAAK,IAAI,CACH,GAAG;AAAM;AAA0B;AAGzC;AACO,IAJG,OAAO,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,EAAC,CAC7C,CAAC;AACN,CAAC;AACD;AACG;AAAe;AAAkB;AAAyB;AAAe;AAAI,SAAhE,iBAAiB,CAAI,GAAU,EAAE,SAAyB;AAAI,IAC5E,OAAO,OAAO,CAAmB,GAAG,EAAE,SAAS,CAAC,CAAC,IAAI,CAAC,GAAG;AAAM;AAA0B;AAEtF;AAAQ,IAF+C,OAAO,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,EAAC,CAAC,CAAC;AACtG;AACA;AAAC;AAAI;AAAkC;AAAqH;AAAI;AAAI;AAA8F;AAAuB;AAAe;AAAoB;AAAyB;AAAe;AAAI,SC3BxV,UAAU,CAAI,KAAY,EAAE,SAAyB;AAAI,IACvE,OAAO,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC;AAC5C,SAAK,IAAI,CACH,GAAG;AAAM;AACK;AACjB;AAAQ,IAFD,MAAM,IACR,MAAM,CAAC,OAAO,CAAC,UAAU,EAAE;AACnC,SAAW,GAAG;AAAM;AAAyB;AAAmB;AAAQ,IAAzD,MAAM,wBAAK,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAA4B,EAAC,EAAC,CAAC,CAAC;AAChG,CAAC;AACD;AACG;AACgF;AAEzE;AAAoB;AAE7B;AAAyB;AACjB;AAAI,SAHG,aAAa,CAC3B,KAAY,EACZ,MAA4B,EAC5B,SAAyB;AAAI,IAC7B,OAAO,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC;AAC5C,SAAK,IAAI,CACH,GAAG;AAAM;AAA0B;AACjC;AAAQ,IADN,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,EAAC,EAC5C,IAAI;AAAM;AAA0B;AAA0B;AAC7D;AAAQ,IADJ,CAAC,OAAO,EAAE,OAAO,KAAK,cAAc,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,GAAE,EAAE,CAAC,EACxE,GAAG;AAAM;AAA0B;AAAmB;AAAQ,IAA1D,OAAO,IAAI,OAAO,CAAC,GAAG;AAAM;AAAoB;AAAmB;AAAQ,IAApD,CAAC,wBAAK,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,EAAE,GAA4B,EAAC,EAAC,CAAC,CAAC;AACnG,CAAC;AACD;AACG;AACkF;AACvE;AAEJ;AAAsB;AAAsB;AAAqB;AAAe;AAAI,SAA9E,cAAc,CAAI,OAA4B,EAAE,OAA4B,EAAE,MAA4B;AAC1H,IAAE,OAAO,CAAC,OAAO;AAAM;AACL;AACf;AAAQ,IAFO,MAAM;AACxB;AACI,QAAA,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;AAC1C,YAAM,OAAO,GAAG,aAAa,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC/C,SAAK;AACL,KAAG,EAAC,CAAC;AACL,IAAE,OAAO,OAAO,CAAC;AACjB,CAAC;AACD;AACG;AAC6C;AAEtC;AAAuB;AAAqB;AAAe;AAAI,SAAzD,aAAa,CAAI,QAA6B,EAAE,MAAyB;AAAI,IAC3F,QAAQ,MAAM,CAAC,IAAI;AACrB,QAAI,KAAK,OAAO;AAChB,YAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAClG;AACQ,aAAD;AAAC,iBAAK;AACb,gBAAQ,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AACpD,aAAO;AACP,YAAM,MAAM;AACZ,QAAI,KAAK,UAAU;AACnB,YAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAC1G;AACQ;AACQ,gBAAR,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,EAAE;AACjD,oBAAU,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC9C,oBAAU,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AACtD,iBAAS;AAAC,qBAAK;AACf,oBAAU,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AACtD,iBAAS;AACT,aAAO;AACP,YAAM,MAAM;AACZ,QAAI,KAAK,SAAS;AAClB,YAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAClG,gBAAQ,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAC5C,aAAO;AACP,YAAM,MAAM;AACZ,KAAG;AACH,IAAE,OAAO,QAAQ,CAAC;AAClB;AACA;AAAC;AAAI;AAAkC;AAAqH;AAAI;AAAI;AAAsB;AAAe;AAAI,SCpE7L,mBAAmB,CAAC,MAA6B;AACjE,IAAE,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACtC,QAAI,MAAM,GAAG,CAAC,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;AAC9C,KAAG;AACH,IAAE,OAAO,MAAM,CAAC;AAChB,CAAC;AACD;AACG;AACkC;AACnC;AACkG;AACJ;AACX;AACnF;AACwF;AACxF;AAC4F;AAC5F;AACS;AACT;AAC+D;AACN;AACsB;AAC/E;AACmE;AACf;AACpD;AAC+F;AAC9B;AAEzD;AAAI,MAAD,0BAA0B;AAAG;AAAQ;AAE0B;AAC1C;AAAO;AAEsC;AACC;AACM;AAC7D;AAGzB;AAAwB;AACxB;AAAQ,IAFN,YACkB,GAAwB,EACvB,KAAY,EACZ,GAAqB;AAAI,QAF1B,QAAG,GAAH,GAAG,CAAqB;AAAC,QACxB,UAAK,GAAL,KAAK,CAAO;AAAC,QACb,QAAG,GAAH,GAAG,CAAkB;AAAC,KAAI;AAC/C;AAEC;AACE;AACE;AAEJ;AAA0B;AAAmB;AAAQ,IAApD,YAAY,CAAC,MAA6B;AAAI,QAC5C,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACxC,YAAM,OAAO,UAAU,CAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,IAAI,CACvE,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACR,SAAK;AACL,QAAI,OAAO,UAAU,CAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,IAAI,CACvE,GAAG;AAAM;AAA8B;AAAuB;AAAY,QAAtE,OAAO,IAAI,OAAO,CAAC,MAAM;AAAM;AAA6B;AAC3D;AAAY,QADa,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAC,EAAC,EAC1E,MAAM;AAAM;AAChB;AAAuB;AAAY,QADxB,OAAO,IAAK,OAAO,CAAC,MAAM,GAAG,CAAC,EAAC,EACtC,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACN,KAAG;AACH;AAEC;AACE;AACE;AACoB;AAAmB;AAAQ,IAAlD,UAAU,CAAC,MAA6B;AAAI,QAC1C,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI;AAAM;AAA8B;AAIjF;AAAuB;AAAY,QAJW,CAAC,OAAO,EAAE,MAAM,KAAK,CAAC,GAAG,OAAO,EAAE,GAAG,MAAM,CAAC,GAAE,EAAE,CAAC,CAAC,CAAC;AAClG,KAAG;AACH;AAEC;AACE;AACE;AACoB;AAAmB;AAAQ,IAAlD,eAAe,CAAC,MAA6B;AAAI;AAAyB,cAClE,eAAe,GAAG,mBAAmB,CAAC,MAAM,CAAC;AACvD;AAAyB,cAAf,uBAAuB,GAAG,aAAa,CAAI,IAAI,CAAC,KAAK,EAAE,eAAe,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC;AACrH,QAAI,OAAO,uBAAuB,CAAC,IAAI,CACjC,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACN,KAAG;AACH;AAEC;AAAmB;AAA2B;AAAmB;AAAQ,IASxE,YAAY,CAAmB,UAAyB,EAAE;AAAI,QAC5D,OAAO,iBAAiB,CAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC;AAC/E,aAAO,IAAI,CACH,GAAG;AAAM;AAA8B;AAChC;AAAY,QADf,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG;AAAM;AAC/B;AACV;AACT,QAH6C,CAAC;AACjD,YAAU,IAAI,OAAO,CAAC,OAAO,EAAE;AAC/B,gBAAY,6EACK,CAAC,CAAC,IAAI,EAAE,KACR,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,CAAC,CAAC,EAAE,EAAE,IACF;AAC1C,aAAW;AAAC,iBAAK;AACjB,gBAAY,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;AAC5B,aAAW;AACX,SAAS,EAAC,EAAC,EACH,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACR,KAAG;AACH;AAEC;AACE;AACqB;AACrB;AAAQ,IADT,GAAG,CAAC,OAA8B;AACpC,QAAI,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CACvC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,aAAa,CAAC,CAC7C,CAAC;AACN,KAAG;AACH;AAEC;AACE;AACE;AACE;AACE;AAEJ;AAAuB;AAC1B;AAAQ,IADR,GAAG,CAAC,IAAO;AAAI,QACb,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAC9B,KAAG;AACH;AAEC;AACE;AACa;AAAwB;AACpC;AAAQ,IADV,GAAG,CAAI,IAAa;AAAI,QACtB,OAAO,IAAI,wBAAwB,CAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACzE,KAAG;AACH,CAAC;AACD;AAAa;AAAqB,IAhG9B,yCAAwC;AAAC;AACtC;AAAiB;AACnB;AAAQ,IADT,2CAA6B;AAAC;AAC3B;AAAiB;AAAgB;AACxC,IADI,yCAAsC;AAAC;AAAE;AAAC;AAE7C;AAC4B;AACyC;AAAI;AAAI;AACpD;AAAG;AAEkD;AAEzC;AAA+B;AAAG;AAI7C;AAAG;AACgB;AAAG;AAAY;AAAG;AAElD;AAKD;AAA0C;AACvD;AAAkB;AAEf;AAA8E;AACf;AAAe;AAAI,MChDxE,wBAAwB;AAAG;AAAQ;AAGe;AACV;AAEjD;AAAsB;AAAQ,IAAhC,YAAmB,GAAsB,EAAU,GAAqB;AAAI,QAAzD,QAAG,GAAH,GAAG,CAAmB;AAAC,QAAS,QAAG,GAAH,GAAG,CAAkB;AAAC,KAAI;AAC/E;AAEC;AACE;AACiB;AAA2B;AACnC;AAAQ,IADlB,GAAG,CAAC,IAAO,EAAE,OAAoB;AAAI,QACnC,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACvC,KAAG;AACH;AAEC;AACE;AACiB;AAAmB;AACpC,IADD,MAAM,CAAC,IAAgB;AAAI,QACzB,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACjC,KAAG;AACH;AAEC;AACE;AACa;AAAQ,IAAtB,MAAM;AAAK,QACT,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;AAC7B,KAAG;AACH;AAEC;AACE;AACE;AACa;AAAuB;AAA2B;AAAmB;AAAQ,IAA7F,UAAU,CAAkB,IAAY,EAAE,OAAiB;AAAI;AAAyB,cAChF,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC;AACnD,cAAU,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC;AACjE,QAAI,OAAO,IAAI,0BAA0B,CAAI,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACnE,KAAG;AACH;AAEC;AACE;AACa;AAAQ,IAAtB,eAAe;AAAK;AAAyB,cACrC,oBAAoB,GAAG,UAAU,CAAI,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC;AAC5F,QAAI,OAAO,oBAAoB,CAAC,IAAI,CAC9B,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACN,KAAG;AACH;AAEC;AACE;AACa;AAAQ,IAAtB,YAAY;AAAK,QACf,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC,IAAI,CAChC,GAAG;AAAM;AACO;AACf;AAEJ,QAJO,MAAM;AAChB,YAAQ,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;AACrC,SAAO,EAAC,CACH,CAAC;AACN,KAAG;AACH;AAEC;AACE;AACqB;AACrB;AAAQ,IADT,GAAG,CAAC,OAA8B;AACpC,QAAI,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CACrC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,aAAa,CAAC,CAC7C,CAAC;AACN,KAAG;AACH,CAAC;AACD;AAAa;AAAqB,IA/DpB,uCAA6B;AAAC;AAAQ;AAAiB;AAEjE;AACE,IAHuC,uCAA6B;AAAC;AAAE;AAAC;AAE7E;AAC4B;AAI3B;AAED;AAAI;AACqC;AAAG;AAEd;AAAG;AAO5B;AAAG;AAK0B;AAAG;AAAY;AAAG;AAG3B;AAA4D;AAExE;AAAG;AAC+B;AAIX;AACpC;AAAI,MC3CQ,+BAA+B;AAAG;AAAQ;AAEY;AACjC;AAE3B;AACO;AAAQ,IADpB,YACmB,KAAY,EACZ,GAAqB;AAAI,QADzB,UAAK,GAAL,KAAK,CAAO;AAAC,QACb,QAAG,GAAH,GAAG,CAAkB;AAAC,KAAI;AAC/C;AAEC;AACE;AACE;AAEJ;AAA0B;AAAmB;AAAQ,IAApD,YAAY,CAAC,MAA6B;AAAI,QAC5C,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACxC,YAAM,OAAO,UAAU,CAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,IAAI,CACvE,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACR,SAAK;AACL,QAAI,OAAO,UAAU,CAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC;AACxE,aAAO,IAAI,CACH,GAAG;AAAM;AAA8B;AAAuB;AAAY,QAAtE,OAAO,IAAI,OAAO,CAAC,MAAM;AAAM;AAA6B;AAC7D;AAAY,QADe,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAC,EAAC,EAC1E,MAAM;AAAM;AAClB;AAAuB;AAAY,QADtB,OAAO,IAAK,OAAO,CAAC,MAAM,GAAG,CAAC,EAAC,EACtC,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACR,KAAG;AACH;AAEC;AACE;AACE;AACoB;AAAmB;AAAQ,IAAlD,UAAU,CAAC,MAA6B;AAAI,QAC1C,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI;AAAM;AAA8B;AAIjF;AAAuB;AAAY,QAJW,CAAC,OAAO,EAAE,MAAM,KAAK,CAAC,GAAG,OAAO,EAAE,GAAG,MAAM,CAAC,GAAE,EAAE,CAAC,CAAC,CAAC;AAClG,KAAG;AACH;AAEC;AACE;AACE;AACoB;AAAmB;AAAQ,IAAlD,eAAe,CAAC,MAA6B;AAAI;AAAyB,cAClE,eAAe,GAAG,mBAAmB,CAAC,MAAM,CAAC;AACvD;AAAyB,cAAf,uBAAuB,GAAG,aAAa,CAAI,IAAI,CAAC,KAAK,EAAE,eAAe,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC;AACrH,QAAI,OAAO,uBAAuB,CAAC,IAAI,CACjC,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACN,KAAG;AACH;AAEC;AACE;AACa;AAAQ,IAAtB,YAAY;AAAK;AACX,cAAE,2BAA2B,GAAG,iBAAiB,CAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC;AAC5G,QAAI,OAAO,2BAA2B;AACtC,aAAO,IAAI,CACH,GAAG;AAAM;AAA8B;AAC1C;AAAY,QADL,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG;AAAM;AACzC;AAAuB;AAC5B,QAFyC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAC,EAAC,EACvD,IAAI,CAAC,GAAG,CAAC,sBAAsB,CAChC,CAAC;AACR,KAAG;AACH;AAEC;AACE;AACqB;AACrB;AAAQ,IADT,GAAG,CAAC,OAA8B;AACpC,QAAI,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CACvC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,aAAa,CAAC,CAC7C,CAAC;AACN,KAAG;AACH,CACC;AACD;AAAa;AAAQ;AAAiB;AAAgB;AAAQ,IAhE1D,gDAA6B;AAAC;AAC3B;AAAiB;AAAgB;AACxC,IADI,8CAAsC;AAAC;AAAE;AAAC;AAE7C;AAC4B;AACyC;AAAI;AAAI;AAG3B;AAAa;AAAI,MCTvD,kBAAkB,GAAG,IAAI,cAAc,CAAU,yCAAyC;AACvG;AAAiB,MAAJ,oBAAoB,GAAG,IAAI,cAAc,CAAkC,4CAA4C;AACpI;AAAiB,MAAJ,QAAQ,GAAG,IAAI,cAAc,CAAW,iCAAiC;AACtF;AACG;AAC6D;AACrD;AACT;AAEC;AAEE;AAAG;AACA;AACA;AAEP;AACG;AAAe;AAAI,SAAP,cAAc,CAAC,aAAkC,EAAE,OAAO;AAAQ;AAAkB;AACjG;AAD0E,GAAG,IAAI,GAAG,CAAA;AAAI;AAC3F,UAAQ,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC;AACtC;AAAqB,UAAb,GAAG,GAAG,aAAa;AAC3B,IAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC;AACxB,CAAC;AACD;AACG;AACwB;AACzB;AAC0E;AACA;AACN;AACpE;AACS;AACT;AAEF;AACC;AACA;AACA;AACA;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAGW,gBAAgB;AAC7B;AAAQ;AACyB;AACgB;AACnB;AAA0B;AAEtD;AACoC;AAA2B;AAC5C;AAAuB;AACpC;AAAQ,IAEd,YAC4B,OAAwB,EACX,YAA2D,EAC1D,uBAAuC,EACjD,QAAyB;AAC1D;AACA,IAAwB,UAAkB,EACvC,IAAY,EAC8B,mBAA+C;AAC1F,QACC,IAAI,CAAC,UAAU,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,CAAC;AACvD,QAAI,IAAI,CAAC,sBAAsB,GAAG,8BAA8B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAClF,QACI,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB;AAAM;AAC7B;AAAY,QADY;AAC5C;AAA6B,kBAAjB,GAAG,GAAG,mBAAmB,CAAC,OAAO,EAAE,IAAI,EAAE,YAAY,CAAC;AAClE;AACM;AACM;AACM,YAAZ,IAAI,iBAAiB,EAAE;AAC7B,gBAAQ,iBAAiB,CAAC,QAAQ,CAAC,CAAC;AACpC,aAAO;AACP;AAA6B,kBAAjB,SAAS,GAAG,GAAG,CAAC,SAAS,EAAE;AACvC,YAAM,IAAI,QAAQ,EAAE;AACpB,gBAAQ,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACrC,aAAO;AACP,YAAM,OAAO,SAAS,CAAC;AACvB,SAAK,EAAC,CAAC;AACP,QACI,IAAI,uBAAuB,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE;AAClE;AACM;AACM;AACX,kBADW,iBAAiB;AAAQ;AAE3B;AAAgB,YAFM;AAChC,gBAAQ,IAAI;AACZ,oBAAU,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,mBAAmB,IAAI,SAAS,CAAC,CAAC,IAAI;AAAM;AACtF;AACE,oBAF+E,MAAM,IAAI;AAAQ;AAE5G;AACJ,oBAH0G,MAAM,KAAK,EAAC,CAAC,CAAC;AACxH,iBAAS;AAAC,gBAAA,OAAO,CAAC,EAAE;AACpB,oBAAU,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAC3B,iBAAS;AACT,aAAO,CAAA;AACP,YAAM,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;AAC3E,SAAK;AAAC,aAAK;AACX,YAAM,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;AAC3C,SAAK;AACL,KAAG;AACH;AAEC;AAAmB;AAA4B;AAC1C;AAAmB;AAAQ,IAM/B,UAAU,CAAI,SAAuC,EAAE,OAAiB;AAAI;AAAyB,YAC/F,aAAkC;AAC1C,QAAI,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;AACvC,YAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;AAC3D,SAAK;AAAC,aAAK;AACX,YAAM,aAAa,GAAG,SAAS,CAAC;AAChC,SAAK;AACL,cAAU,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC;AACjE;AAAyB,cAAf,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG;AAAM;AACtC;AAAY,QADqB,MAAM,GAAG,EAAC;AAC3D,QAAI,OAAO,IAAI,0BAA0B,CAAI,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AACrE,KAAG;AACH;AAEC;AACE;AACE;AAEJ;AAAmB;AAA+B;AAAgC;AAAmB;AACtG,IADE,eAAe,CAAI,YAAoB,EAAE,YAA2B;AAAI;AAAyB,cACzF,OAAO,GAAG,YAAY;AAAU;AACxB;AAAuB;AAAY,QADhB,GAAG,IAAI,GAAG,EAAC;AAChD;AAAyB,cAAf,eAAe,GAAU,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,YAAY,CAAC;AAC/E,QAAI,OAAO,IAAI,+BAA+B,CAAI,OAAO,CAAC,eAAe,CAAC,EAAE,IAAI,CAAC,CAAC;AAClF,KAAG;AACH;AAEC;AAAmB;AAA4B;AAChD;AAAQ,IAON,GAAG,CAAI,SAAqC;AAAI;AAAyB,YACnE,GAAsB;AAC9B,QAAI,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;AACvC,YAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AAC1C,SAAK;AAAC,aAAK;AACX,YAAM,GAAG,GAAG,SAAS,CAAC;AACtB,SAAK;AACL;AAAyB,cAAf,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG;AAAM;AACtC;AAAY,QADqB,MAAM,GAAG,EAAC;AAC3D,QAAI,OAAO,IAAI,wBAAwB,CAAI,SAAS,EAAE,IAAI,CAAC,CAAC;AAC5D,KAAG;AACH;AAEC;AACE;AAEF;AAAQ,IADP,QAAQ;AACV,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC;AACnD,KAAG;AACH;4CAnHC,UAAU,SAAC,kBACV,UAAU,EAAE,KAAK,cAClB,6OACI;AAAC;AAAmB;AACU,4CAW9B,MAAM,SAAC,gBAAgB;AAAS,4CAChC,QAAQ,YAAI,MAAM,SAAC,iBAAiB;AAAS,4CAC7C,QAAQ,YAAI,MAAM,SAAC,kBAAkB;AAAS,4CAC9C,QAAQ,YAAI,MAAM,SAAC,QAAQ;AAAS,YAEJ,MAAM,uBAAtC,MAAM,SAAC,WAAW;AAAS,YAlIa,MAAM;AAAI,4CAoIlD,QAAQ,YAAI,MAAM,SAAC,oBAAoB;AAAQ;AAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAOsB;AAAC;AAAa;AACvF,IA1BF,qCAA+C;AACjD;AAAqB,IAAnB,+CAAyD;AAC3D;AAAqB,IAAnB,sCAAmD;AACrD;AAAqB,IAAnB,kDAAiF;AACnF;AACC;AAAC;AACF;AAAkC;AAE9B;AAAI,MCnHK,sBAAsB;AACnC;AACE;AACE;AACiC;AAAmB;AAAQ,IAA9D,OAAO,iBAAiB,CAAC,mBAAyC;AAAI,QACpE,OAAO;AACX,YAAM,QAAQ,EAAE,sBAAsB;AACtC,YAAM,SAAS,EAAE;AACjB,gBAAQ,EAAE,OAAO,EAAE,kBAAkB,EAAE,QAAQ,EAAE,IAAI,EAAE;AACvD,gBAAQ,EAAE,OAAO,EAAE,oBAAoB,EAAE,QAAQ,EAAE,mBAAmB,EAAE;AACxE,aAAO;AACP,SAAK,CAAC;AACN,KAAG;AACH;kDAhBC,QAAQ,SAAC,kBACR;KAAS,EAAE,CAAE,gBAAgB,CAAE,cAChC;;;;;;0BACI;AAAC;AAAC;AAAI;AAEV;AAEwD;AAAI;AAAI;AAAW;AAAe;AACzF,qCCMD;AACD;AACY;AAAqB,IAJ/B,wCAAsB;AACxB;AAAQ;AAA2B;AAGtB;AAAQ,IAHnB,+DAAmC;AACrC;AACA;AACG;AAAW;AAAI,2CAIjB;AACD;AACY;AAAqB,IAL/B,8CAAuB;AACzB;AAAQ;AAA2B;AAC3B;AAAQ,IADd,qEAA2C;AAC7C;AAAQ;AAA4B;AAA2B;AAG5D;AAAQ,IAHT,+EAAyE;AAC3E;AACA;AACG;AAAW;AAAe;AAAI,oCAIhC;AACD;AACY;AAAQ;AAA2B;AAAmB;AAC5D,IAJJ,8DAAmC;AACrC;AACA;AACG;AAAW;AAAe;AAAI,4BAEhC;AACD;AACY;AAAqB,IAH/B,6BAA0C;AAC5C;AACA;AACG;AAAW;AAAe;AAAI,6BAEhC;AACD;AACY;AAAqB,IAH/B,6BAAuC;AACzC;AACA;AACG;AAAW;AAAe;AAAI,mCAGhC;AACD;AACY;AACR,IALF,oCAAyB;AAC3B;AAAqB,IAAnB,uCAA2B;AAC7B;AACA;AACG;AAAW;AACd;AAAI,qBAEH;AACD;AACY;AACX,IALC,sBAAa;AACf;AAGI,IAHF,yBAAW;AACb;AACA;AACG;AAAW;AAAe;AAC5B,wBACA;AACD;AACY;AAAqB,IAH/B,+BAA0C;AAC5C;AACA;AACG;AACwB;AACJ;AAEO;AAAY;AAAG;AAG7C;AAAG;AAAkD;AACjB;AACd;AACX;AAIgC;AAAG;AAEpC;AAAa;AAAsB;AAC/B;AAAwB;AACvB;AAAO;AAAW;AAAI,kCAapC;AACD;AAAa;AAAqB,IAHhC,kCAAyB;AAC3B;AAEG,IAFD,oCAAa;AACf;AACA;AAAC;AAAI;AAAkC;AAAqH;AAAI;AAAC;AAAI;AAAkC;AAAqH;AAAI;AAAC;AAAuU","sourcesContent":["import { asyncScheduler, Observable, SchedulerLike } from 'rxjs';\nimport { Action, DocumentReference, DocumentSnapshot, Query, QuerySnapshot, Reference } from '../interfaces';\nimport { map } from 'rxjs/operators';\n\nfunction _fromRef<T, R>(ref: Reference<T>, scheduler: SchedulerLike = asyncScheduler): Observable<R> {\n  return new Observable(subscriber => {\n    let unsubscribe;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot(subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot(subscriber);\n    }\n\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\n\nexport function fromRef<R>(ref: DocumentReference | Query, scheduler?: SchedulerLike) {\n  return _fromRef<typeof ref, R>(ref, scheduler);\n}\n\nexport function fromDocRef<T>(ref: DocumentReference, scheduler?: SchedulerLike): Observable<Action<DocumentSnapshot<T>>> {\n  return fromRef<DocumentSnapshot<T>>(ref, scheduler)\n    .pipe(\n      map(payload => ({ payload, type: 'value' }))\n    );\n}\n\nexport function fromCollectionRef<T>(ref: Query, scheduler?: SchedulerLike): Observable<Action<QuerySnapshot<T>>> {\n  return fromRef<QuerySnapshot<T>>(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n","import { fromCollectionRef } from '../observable/fromRef';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { map, scan } from 'rxjs/operators';\n\nimport { DocumentChange, DocumentChangeAction, DocumentChangeType, Query } from '../interfaces';\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(action =>\n        action.payload.docChanges()\n          .map(change => ({ type: change.type, payload: change } as DocumentChangeAction<T>))));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nexport function sortedChanges<T>(\n  query: Query,\n  events: DocumentChangeType[],\n  scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(changes => changes.payload.docChanges()),\n      scan((current, changes) => combineChanges(current, changes, events), []),\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Creates a new sorted array from a new change.\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        combined.splice(change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n","import { from, Observable } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { filter, map, observeOn, scan } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { CollectionReference, DocumentChangeAction, DocumentChangeType, DocumentData, DocumentReference, Query } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T= DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(\n    public readonly ref: CollectionReference,\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if (!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n      map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n      filter(changes =>  changes.length > 0),\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // tslint:disable-next-line:unified-signatures\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as {},\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   */\n  doc<T>(path?: string): AngularFirestoreDocument<T> {\n    return new AngularFirestoreDocument<T>(this.ref.doc(path), this.afs);\n  }\n}\n","import { from, Observable } from 'rxjs';\nimport { Action, DocumentData, DocumentReference, DocumentSnapshot, QueryFn, SetOptions } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport { firestore } from 'firebase/app';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T= DocumentData> {\n\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(public ref: DocumentReference, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n  collection<R= DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path);\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<R>(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   */\n  valueChanges(): Observable<T|undefined> {\n    return this.snapshotChanges().pipe(\n      map(action => {\n        return action.payload.data();\n      })\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n}\n","import { from, Observable } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { filter, map, observeOn, scan } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeAction, DocumentChangeType, DocumentData, Query } from '../interfaces';\nimport { validateEventsArray } from '../collection/collection';\nimport { docChanges, sortedChanges } from '../collection/changes';\nimport { AngularFirestore } from '../firestore';\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollectionGroup<T= DocumentData> {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if (!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   */\n  valueChanges(): Observable<T[]> {\n    const fromCollectionRefScheduled$ = fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$\n      .pipe(\n        map(actions => actions.payload.docs.map(a => a.data())),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular)\n    );\n  }\n\n}\n","import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { from, Observable, of } from 'rxjs';\nimport {\n  AssociatedReference,\n  CollectionReference,\n  DocumentReference,\n  PersistenceSettings,\n  Query,\n  QueryFn,\n  QueryGroupFn,\n  Settings\n} from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport {\n  FIREBASE_APP_NAME,\n  FIREBASE_OPTIONS,\n  FirebaseAppConfig,\n  FirebaseOptions,\n  ɵAngularFireSchedulers,\n  ɵfirebaseAppFactory,\n  ɵkeepUnstableUntilFirstFactory\n} from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport { firestore } from 'firebase/app';\nimport firebase from '@firebase/app';\nimport { registerFirestore } from '@firebase/firestore';\nimport 'firebase/firestore';\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const ENABLE_PERSISTENCE = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PERSISTENCE_SETTINGS = new InjectionToken<PersistenceSettings | undefined>('angularfire2.firestore.persistenceSettings');\nexport const SETTINGS = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery(collectionRef: CollectionReference, queryFn = ref => ref): AssociatedReference {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirestore {\n  public readonly firestore: firestore.Firestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig: string | FirebaseAppConfig | null | undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean | null,\n    @Optional() @Inject(SETTINGS) settings: Settings | null,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings | null\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n\n    this.firestore = zone.runOutsideAngular(() => {\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n      // INVESTIGATE this seems to be required because in the browser build registerFirestore is an Object?\n      //             seems like we're fighting ngcc. In the server firestore() isn't available, so I have to register\n      //             in the browser registerFirestore is not a function... maybe this is an underlying firebase-js-sdk issue\n      if (registerFirestore) {\n        registerFirestore(firebase);\n      }\n      const firestore = app.firestore();\n      if (settings) {\n        firestore.settings(settings);\n      }\n      return firestore;\n    });\n\n    if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n      // We need to try/catch here because not all enablePersistence() failures are caught\n      // https://github.com/firebase/firebase-js-sdk/issues/608\n      const enablePersistence = () => {\n        try {\n          return from(this.firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n        } catch (e) {\n          return of(false);\n        }\n      };\n      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n    } else {\n      this.persistenceEnabled$ = of(false);\n    }\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  // tslint:disable-next-line:unified-signatures\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  collection<T>(pathOrRef: string | CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreCollection<T>(refInZone, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn): AngularFirestoreCollectionGroup<T> {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup: Query = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>;\n  // tslint:disable-next-line:unified-signatures\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>;\n  doc<T>(pathOrRef: string | DocumentReference): AngularFirestoreDocument<T> {\n    let ref: DocumentReference;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreDocument<T>(refInZone, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { PersistenceSettings } from './interfaces';\nimport { AngularFirestore, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS } from './firestore';\n\n@NgModule({\n  providers: [ AngularFirestore ]\n})\nexport class AngularFirestoreModule {\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings?: PersistenceSettings): ModuleWithProviders {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [\n        { provide: ENABLE_PERSISTENCE, useValue: true },\n        { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n      ]\n    };\n  }\n}\n","import { Subscriber } from 'rxjs';\nimport { firestore } from 'firebase/app';\n\nexport type Settings =  firestore.Settings;\nexport type CollectionReference = firestore.CollectionReference;\nexport type DocumentReference = firestore.DocumentReference;\nexport type PersistenceSettings = firestore.PersistenceSettings;\nexport type DocumentChangeType = firestore.DocumentChangeType;\nexport type SnapshotOptions = firestore.SnapshotOptions;\nexport type FieldPath = firestore.FieldPath;\nexport type Query = firestore.Query;\n\nexport type SetOptions = firestore.SetOptions;\nexport type DocumentData = firestore.DocumentData;\n\nexport interface DocumentSnapshotExists<T> extends firestore.DocumentSnapshot {\n  readonly exists: true;\n  data(options?: SnapshotOptions): T;\n}\n\nexport interface DocumentSnapshotDoesNotExist extends firestore.DocumentSnapshot {\n  readonly exists: false;\n  data(options?: SnapshotOptions): undefined;\n  get(fieldPath: string | FieldPath, options?: SnapshotOptions): undefined;\n}\n\nexport type DocumentSnapshot<T> = DocumentSnapshotExists<T> | DocumentSnapshotDoesNotExist;\n\nexport interface QueryDocumentSnapshot<T> extends firestore.QueryDocumentSnapshot {\n  data(options?: SnapshotOptions): T;\n}\n\nexport interface QuerySnapshot<T> extends firestore.QuerySnapshot {\n  readonly docs: QueryDocumentSnapshot<T>[];\n}\n\nexport interface DocumentChange<T> extends firestore.DocumentChange {\n  readonly doc: QueryDocumentSnapshot<T>;\n}\n\nexport interface DocumentChangeAction<T> {\n  type: DocumentChangeType;\n  payload: DocumentChange<T>;\n}\n\nexport interface Action<T> {\n  type: string;\n  payload: T;\n}\n\nexport interface Reference<T> {\n  onSnapshot: (sub: Subscriber<any>) => any;\n}\n\n// A convience type for making a query.\n// Example: const query = (ref) => ref.where('name', == 'david');\nexport type QueryFn = (ref: CollectionReference) => Query;\n\nexport type QueryGroupFn = (query: Query) => Query;\n\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n */\nexport interface AssociatedReference {\n  ref: CollectionReference;\n  query: Query;\n}\n"]}