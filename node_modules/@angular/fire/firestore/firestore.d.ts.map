{"version":3,"file":"firestore.d.ts","sources":["firestore.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { InjectionToken, NgZone } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { AssociatedReference, CollectionReference, DocumentReference, PersistenceSettings, QueryFn, QueryGroupFn, Settings } from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport { FirebaseAppConfig, FirebaseOptions, ɵAngularFireSchedulers } from '@angular/fire';\nimport { firestore } from 'firebase/app';\nimport 'firebase/firestore';\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport declare const ENABLE_PERSISTENCE: InjectionToken<boolean>;\nexport declare const PERSISTENCE_SETTINGS: InjectionToken<firestore.PersistenceSettings>;\nexport declare const SETTINGS: InjectionToken<firestore.Settings>;\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport declare function associateQuery(collectionRef: CollectionReference, queryFn?: (ref: any) => any): AssociatedReference;\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\nexport declare class AngularFirestore {\n    readonly firestore: firestore.Firestore;\n    readonly persistenceEnabled$: Observable<boolean>;\n    readonly schedulers: ɵAngularFireSchedulers;\n    readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n    /**\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\n     * don't rely on the main Firebase App instance and we can create named\n     * apps and use multiple apps.\n     */\n    constructor(options: FirebaseOptions, nameOrConfig: string | FirebaseAppConfig | null | undefined, shouldEnablePersistence: boolean | null, settings: Settings | null, platformId: Object, zone: NgZone, persistenceSettings: PersistenceSettings | null);\n    /**\n     * Create a reference to a Firestore Collection based on a path or\n     * CollectionReference and an optional query function to narrow the result\n     * set.\n     */\n    collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n    collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n    /**\n     * Create a reference to a Firestore Collection Group based on a collectionId\n     * and an optional query function to narrow the result\n     * set.\n     */\n    collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn): AngularFirestoreCollectionGroup<T>;\n    /**\n     * Create a reference to a Firestore Document based on a path or\n     * DocumentReference. Note that documents are not queryable because they are\n     * simply objects. However, documents have sub-collections that return a\n     * Collection reference and can be queried.\n     */\n    doc<T>(path: string): AngularFirestoreDocument<T>;\n    doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>;\n    /**\n     * Returns a generated Firestore Document Id.\n     */\n    createId(): string;\n}\n"]}